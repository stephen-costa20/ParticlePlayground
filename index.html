<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive AI Particle System</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Glassmorphism UI */
        .ui-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .video-feed {
            transform: scaleX(-1); /* Mirror effect */
            opacity: 0.2;
            pointer-events: none;
        }
        
        /* Custom Scrollbar for button list */
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 50; display: flex; justify-content: center; align-items: center;
            color: #00ff88; font-size: 1.2rem; letter-spacing: 2px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="loader" class="loading-overlay">
        INITIALIZING AI VISION & GPU...
    </div>

    <div id="canvas-container"></div>

    <video id="input_video" class="video-feed absolute bottom-4 right-4 w-48 rounded-lg border border-gray-700 z-0"></video>

    <div class="absolute top-6 left-6 z-20 w-64 ui-panel rounded-2xl p-5 text-white">
        <h1 class="text-xl font-bold mb-1 bg-clip-text text-transparent bg-gradient-to-r from-teal-400 to-blue-500">
            Particle Morph
        </h1>
        <p class="text-xs text-gray-400 mb-4">Move hands apart to expand. Pinch to scatter.</p>

        <div class="mb-5">
            <label class="text-xs font-semibold uppercase tracking-wider text-gray-500 block mb-2">Base Color</label>
            <div class="flex items-center gap-3">
                <input type="color" id="colorPicker" value="#00ffff" 
                       class="w-8 h-8 rounded-full cursor-pointer border-none bg-transparent">
                <span class="text-sm font-mono text-gray-300" id="colorLabel">#00FFFF</span>
            </div>
        </div>

        <div class="mb-2">
            <label class="text-xs font-semibold uppercase tracking-wider text-gray-500 block mb-2">Templates</label>
            <div class="grid grid-cols-2 gap-2 max-h-48 overflow-y-auto custom-scroll">
                <button onclick="setShape('heart')" class="p-2 rounded bg-white/5 hover:bg-white/10 text-xs transition border border-white/5">‚ù§Ô∏è Heart</button>
                <button onclick="setShape('sphere')" class="p-2 rounded bg-white/5 hover:bg-white/10 text-xs transition border border-white/5">ü™ê Saturn</button>
                <button onclick="setShape('flower')" class="p-2 rounded bg-white/5 hover:bg-white/10 text-xs transition border border-white/5">üå∏ Flower</button>
                <button onclick="setShape('helix')" class="p-2 rounded bg-white/5 hover:bg-white/10 text-xs transition border border-white/5">üß¨ DNA</button>
                <button onclick="setShape('fireworks')" class="p-2 rounded bg-white/5 hover:bg-white/10 text-xs transition border border-white/5">üéÜ Fireworks</button>
            </div>
        </div>
        
        <div class="mt-4 pt-4 border-t border-white/10">
            <div class="flex justify-between text-xs text-gray-400">
                <span>Expansion:</span>
                <span id="expansion-val" class="text-teal-400">0%</span>
            </div>
        </div>
    </div>

<script>
    // --- 1. CONFIGURATION ---
    const CONFIG = {
        particleCount: 5000,
        particleSize: 0.15,
        defaultColor: 0x00ffff,
        morphSpeed: 0.03, 
        drag: 0.05,       // Smoothness of expansion
        rotateSpeed: 0.05 // Smoothness of rotation
    };

    // --- 2. THREE.JS SETUP ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 30;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    // Particles Setup
    let geometry = new THREE.BufferGeometry();
    let positions = new Float32Array(CONFIG.particleCount * 3);
    let targetPositions = new Float32Array(CONFIG.particleCount * 3);
    
    for (let i = 0; i < CONFIG.particleCount * 3; i++) {
        positions[i] = (Math.random() - 0.5) * 50;
        targetPositions[i] = positions[i];
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: CONFIG.defaultColor,
        size: CONFIG.particleSize,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. SHAPE GENERATORS ---
    function randomSpherePoint(radius) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = Math.cbrt(Math.random()) * radius; 
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    const Shapes = {
        sphere: () => { 
            const arr = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                if (i < CONFIG.particleCount * 0.7) {
                    const p = randomSpherePoint(6);
                    arr.push(p.x, p.y, p.z);
                } else {
                    const angle = Math.random() * Math.PI * 2;
                    const r = 8 + Math.random() * 4;
                    arr.push(r * Math.cos(angle), (Math.random()-0.5), r * Math.sin(angle));
                }
            }
            return arr;
        },
        heart: () => {
            const arr = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                let t = Math.random() * Math.PI * 2;
                let r = Math.sqrt(Math.random()); 
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 4;
                arr.push(x * 0.5 * r, y * 0.5 * r, z * r);
            }
            return arr;
        },
        flower: () => {
            const arr = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = 5 * Math.cos(4 * theta);
                arr.push(
                    r * Math.sin(phi) * Math.cos(theta) * 2,
                    r * Math.sin(phi) * Math.sin(theta) * 2,
                    r * Math.cos(phi) * 2
                );
            }
            return arr;
        },
        helix: () => { 
            const arr = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const t = i * 0.01;
                const r = 5;
                const x = r * Math.cos(t);
                const y = (i * 0.02) - 10;
                const z = r * Math.sin(t);
                if (i % 2 === 0) { arr.push(x, y, z); } 
                else { arr.push(-x, y, -z); }
            }
            return arr;
        },
        fireworks: () => {
            const arr = [];
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const p = randomSpherePoint(15);
                arr.push(p.x, p.y, p.z);
            }
            return arr;
        }
    };

    let currentShapeData = Shapes.sphere();
    updateTargets(currentShapeData);

    function setShape(type) {
        if(Shapes[type]) {
            currentShapeData = Shapes[type]();
            updateTargets(currentShapeData);
        }
    }

    function updateTargets(data) {
        for(let i=0; i<data.length; i++) {
            targetPositions[i] = data[i];
        }
    }

    const colorPicker = document.getElementById('colorPicker');
    const colorLabel = document.getElementById('colorLabel');

    colorPicker.addEventListener('input', (e) => {
        const color = new THREE.Color(e.target.value);
        material.color = color;
        colorLabel.innerText = e.target.value.toUpperCase();
    });

    // --- 4. HAND TRACKING (POS & SCALE) ---
    const videoElement = document.getElementById('input_video');
    
    // Smooth variables
    let targetHandVal = 0.5; 
    let currentHandVal = 0.5;
    
    // Rotation variables
    let targetRotX = 0;
    let targetRotY = 0;

    const DEAD_ZONE = 0.05;

    function onResults(results) {
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 500);

        let newRawVal = 0.5;
        let centerX = 0.5; // Neutral center
        let centerY = 0.5;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            
            // --- ROTATION LOGIC ---
            // Calculate the centroid (center point) of user's interaction
            if (results.multiHandLandmarks.length === 2) {
                const h1 = results.multiHandLandmarks[0][0]; // Wrist
                const h2 = results.multiHandLandmarks[1][0]; // Wrist
                centerX = (h1.x + h2.x) / 2;
                centerY = (h1.y + h2.y) / 2;
            } else {
                const h1 = results.multiHandLandmarks[0][9]; // Middle finger knuckle
                centerX = h1.x;
                centerY = h1.y;
            }

            // Map Screen Position (0..1) to Rotation (-Angle .. +Angle)
            // Note: Camera feed is mirrored, so we invert X math
            targetRotY = (centerX - 0.5) * 3; // Look left/right
            targetRotX = (centerY - 0.5) * 2; // Look up/down

            // --- EXPANSION LOGIC ---
            if (results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0][0]; 
                const hand2 = results.multiHandLandmarks[1][0]; 
                const dist = Math.sqrt(Math.pow(hand1.x - hand2.x, 2) + Math.pow(hand1.y - hand2.y, 2));
                newRawVal = (dist - 0.2) * 1.6;
            } else {
                const hand = results.multiHandLandmarks[0];
                const thumb = hand[4];
                const index = hand[8];
                const dist = Math.sqrt(Math.pow(thumb.x-index.x, 2) + Math.pow(thumb.y-index.y, 2));
                newRawVal = dist * 3.5; 
            }
        } 

        // Clamp & Dead Zone
        newRawVal = Math.max(0, Math.min(1.2, newRawVal));
        if (Math.abs(newRawVal - targetHandVal) > DEAD_ZONE) {
            targetHandVal = newRawVal;
        }
        
        document.getElementById('expansion-val').innerText = Math.round(currentHandVal * 100) + "%";
    }

    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640,
        height: 480
    });
    cameraUtils.start();

    // --- 5. ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // 1. Smooth Scale
        currentHandVal += (targetHandVal - currentHandVal) * CONFIG.drag;
        
        // 2. Smooth Rotation (Lerp towards target based on hand pos)
        particles.rotation.y += (targetRotY - particles.rotation.y) * CONFIG.rotateSpeed;
        particles.rotation.x += (targetRotX - particles.rotation.x) * CONFIG.rotateSpeed;

        const positionsAttribute = geometry.attributes.position;
        const array = positionsAttribute.array;

        // Apply Gentle Scale Curve
        const delta = currentHandVal - 0.5;
        const scaleFactor = 1 + (delta * 0.6); 
        
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            
            let cx = array[idx];
            let cy = array[idx + 1];
            let cz = array[idx + 2];
            
            let tx = targetPositions[idx];
            let ty = targetPositions[idx + 1];
            let tz = targetPositions[idx + 2];

            // Morph logic
            cx += (tx - cx) * CONFIG.morphSpeed;
            cy += (ty - cy) * CONFIG.morphSpeed;
            cz += (tz - cz) * CONFIG.morphSpeed;

            // Apply Scale
            array[idx] = cx * scaleFactor;
            array[idx + 1] = cy * scaleFactor;
            array[idx + 2] = cz * scaleFactor;
        }

        positionsAttribute.needsUpdate = true;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>